要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是共享的（shared）和可变的（mutable）状态的访问。
共享意味着变量可以被多个线程同时访问，可变意味着变量的值在生命周期内可以发生变化。
线程安全性是代码上使用的一个术语，但它只是与状态相关的，因此只能应用于封装其状态的整个代码，这可能是一个对象，也可能是整个程序。
什么是线程安全性？
正确性的含义是，某个类的行为与其规范完全一致。在良好的规范中通常会定义各种不变性条件（Invariant）来约束对象的状态，以及定义各种
后验条件（Postcondition）来描述对象操作的结果。如果正确的实现了某个对象，那么在任何操作中（包括调用对象的公有方法或者对其公有域
进行读写操作）都不会违背不变形条件或者后验条件。在线程安全类的对象实例上执行任何串行或者并行操作都不会使对象处于无效状态。

**不变形条件、后验条件如何理解

无状态对象一定是线程安全的。

原子性
竞态条件：在并发编程中，由于不恰当的执行时序而出现不正确的结果，这种情况称为竞态条件(Race condition)。
最常见的竞态条件就是“先检查后执行（check-then-act）”，使用它的一种常见情况就是延迟初始化。延迟初始化的目的就是将对象的初始化操作推迟到实际被使用时才进行，同时要确保只被初始化一次。
竞态条件很容易和“数据竞争”混淆

**数据竞争如何理解
如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程之间没有使用同步，那么就可能出现数据竞争。

demo-LazyInitRace中包含一个竞态条件，它可能会破坏这个类的正确性。
demo-UnsafeCountingFactorizer中存在另一种竞态条件

复合操作：LazyInitRace和UnsafeCountingFactorizer都包含一组需要以原子方式执行（或者说不可分割）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量。

原子操作是指，对于访问同一状态的所有操作（包括该操作本身）来说，这个操作是一个以原子方式执行的操作。
为了确保线程安全性，竞态条件必须是原子操作，而复合操作是包含一组必须要以原子方式执行的操作以确保线程安全性。
当在无状态的类中添加一个状态时，如果该状态完全由线程安全的对象来管理，那么这个类仍然是线程安全的。而当状态变量的数量由一个变为多个时，并不会像状态变量由零个变为一个那样简单。要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

内置锁
Java提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized来修饰的方法就是一种横跨整个方法体的同步代码块，其中该同步代码块的锁就是方法调用所在的对象。静态的synchronized方法以Class对象作为锁。每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或监事器锁(Monitor Lock)。线程进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，可以抛出代码块中抛出异常退出。获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。内置锁相当于互斥体（或者互斥锁），这意味着最多只有一个线程能持有这种锁。

**重入 没看懂

用锁来保护状态
由于锁能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能保持状态的一致性。如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置都需要好使用同一个锁。
一种常见的错误是认为，只有在写入共享变量时才需要使用同步。对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是由这个锁保护的。

每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。


