volatile

线程的状态转换

竞态条件是指在并发编程中，由于不恰当的执行时序而出现不正确的结果。大多数竞态条件的本质是基于一种可能失效的观察结果来做出判断或者执行某个计算，即先检查后执行，但在执行的时候前一步的观察结果可能已经变得无效了。

数据竞争是指，如果在访问共享的非final类型的域时没有采用同步来进行协同，那么就会出现数据竞争。当一个线程写入一个变量而另一个线程接下来读取这个变量，或者读取一个之前由另一个线程写入的变量时，并且在这两个线程之间没有使用同步，那么就可能出现数据竞争。

复合操作
一组需要以原子方式执行（或者说不可分割）的操作。

要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。

内置锁
Java提供了一种内置的锁机制来支持原子性：同步代码块。同步代码块包含两部分：1作为锁的对象引用2作为由这个锁保护的代码块。每个Java对象都可以用做一个实现同步的锁，这些锁被称为内置锁或者监视锁。线程进入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁。Java的内置锁相当于一种互斥锁，这意味着最多只有一个线程能持有这种锁。

某个变量由锁来保护时，意味着在每次访问这个变量时都需要首先获得锁，这样确保在同一时刻只有一个线程可以访问这个变量。当类的不变性条件涉及多个状态变量时，那么还有另外一个需求：在不变形条件中每个变量都必须由同一个锁来保护。因此可以在单个原子操作中访问或更新这些变量，从而确保不变形条件不被破坏。